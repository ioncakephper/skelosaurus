// Generated by Qodo Gen

const {slugifyPath} = require('../../lib/skelo-utils')

describe('slugifyPath', () => {

    // Converts a valid string path into a slugified path without filename when input does not end with a forward slash
    it('should convert a valid string path into a slugified path without filename when input does not end with forward slash', () => {
      const input = 'folder/subfolder';
      const expectedOutput = 'folder/subfolder'; // Assuming slug function doesn't change valid characters
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Throws an error for non-string input
    it('should throw an error when input is not a string', () => {
      expect(() => slugifyPath(123)).toThrow('Path must be a string');
    });

    // Handles paths with mixed separators correctly when input does not end with filename
    it('should handle paths with mixed separators correctly when input does not end with filename', () => {
      const input = 'folder\\subfolder/file';
      const expectedOutput = 'folder/subfolder/file'; // Assuming slug function doesn't change valid characters
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Returns an empty string for empty input
    it('should return an empty string when input is empty', () => {
      const input = '';
      const result = slugifyPath(input);
      expect(result).toBe('');
    });

    // Throws an error when path contains harmful characters without a filename
    it('should throw an error when path contains harmful characters without a filename', () => {
      const input = 'folder/../subfolder/';
      expect(() => slugifyPath(input)).toThrow('Invalid path: potentially harmful characters detected in input \'folder/../subfolder/\'');
    });

    // Handles paths with leading and trailing separators correctly when input does not end with a filename
    it('should handle paths with leading and trailing separators correctly when input does not end with a filename', () => {
      const input = '/folder/subfolder/';
      const expectedOutput = 'folder/subfolder'; // Assuming slug function doesn't change valid characters
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Handles paths with consecutive separators by removing empty segments when input ends with double forward slash
    it('should handle paths with consecutive separators by removing empty segments when input ends with double forward slash', () => {
      const input = 'folder//subfolder//';
      const expectedOutput = 'folder/subfolder'; // Assuming slug function doesn't change valid characters
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Handles paths with only separators
    it('should return an empty string when path contains only separators', () => {
      const input = '////';
      const expectedOutput = '';
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Throws an error when path contains harmful characters and input doesn't end with filename
    it('should throw an error when path contains harmful characters and input doesn\'t end with filename', () => {
      const input = 'folder/../subfolder/';
      expect(() => slugifyPath(input)).toThrow('Invalid path: potentially harmful characters detected in input \'folder/../subfolder/\'');
    });

    // Handles paths with empty segments by removing them when input ends with only two forward slashes
    it('should handle paths with empty segments by removing them when input ends with only two forward slashes', () => {
      const input = 'folder//subfolder//';
      const expectedOutput = 'folder/subfolder'; // Assuming slug function doesn't change valid characters
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Processes paths with segments that are only whitespace
    it('should return an empty string when path segments are only whitespace', () => {
      const input = '   /   /   ';
      const expectedOutput = '';
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });

    // Handles paths with segments that are already slugs
    it('should return the same path when all segments are already slugs', () => {
      const input = 'already/slugified/path';
      const expectedOutput = 'already/slugified/path';
      const result = slugifyPath(input);
      expect(result).toBe(expectedOutput);
    });
});
