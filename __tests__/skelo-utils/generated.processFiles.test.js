// Generated by Qodo Gen

const { processFiles } = require('../../lib/skelo-utils');
const {retrieveFilenames, validateFiles, sendMessage} = require('../../lib/skelo-utils');
describe('processFiles', () => {

    // Successfully processes files when given valid schema path and patterns
    it('should process files successfully when given a valid schema path and patterns', () => {
      const path = require('path');
      const fs = require('fs');
      jest.mock('fs');
      jest.mock('path');
      jest.mock('retrieveFilenames');
      jest.mock('validateFiles');
      jest.mock('sendMessage');

    //   const retrieveFilenames = require('./retrieveFilenames');
    //   const validateFiles = require('./validateFiles');
    //   const sendMessage = require('./sendMessage');

      const options = { schema: '/valid/schema/path', verbose: true };
      const patterns = ['pattern1', 'pattern2'];
      const fallbackPatterns = ['fallbackPattern1'];
      const outlineSchema = { /* mock schema */ };
      const files = ['file1', 'file2'];
      const validationResult = { valid: ['file1'], invalid: ['file2'] };

      fs.existsSync.mockReturnValue(true);
      path.isAbsolute.mockReturnValue(true);
      jest.mock('/valid/schema/path', () => outlineSchema, { virtual: true });
      retrieveFilenames.mockReturnValue(files);
      validateFiles.mockReturnValue(validationResult);

      const result = processFiles(options, patterns, fallbackPatterns);

      expect(result).toEqual(validationResult);
      expect(sendMessage).toHaveBeenCalledWith(true, 'skelosaurus', 'info', expect.stringContaining('Invalid files'));
      expect(sendMessage).toHaveBeenCalledWith(true, 'skelosaurus', 'info', expect.stringContaining('Valid files'));
    });

    // Handles non-existent schema path gracefully
    it('should handle non-existent schema path gracefully', () => {
      const fs = require('fs');
      jest.mock('fs');
      jest.mock('./sendMessage');

      const sendMessage = require('./sendMessage');

      const options = { schema: '/invalid/schema/path', verbose: false };
      const patterns = ['pattern1'];
      const fallbackPatterns = ['fallbackPattern1'];

      fs.existsSync.mockReturnValue(false);

      const result = processFiles(options, patterns, fallbackPatterns);

      expect(result).toEqual({ valid: [], invalid: [] });
      expect(sendMessage).toHaveBeenCalledWith(true, 'skelosaurus', 'error', expect.stringContaining('Error processing files'));
    });

    // Returns valid and invalid files when schema and patterns are correct
    it('should return valid and invalid files when schema and patterns are correct', () => {
      const path = require('path');
      const fs = require('fs');
      jest.mock('fs');
      jest.mock('path');
      jest.mock('./retrieveFilenames');
      jest.mock('./validateFiles');
  
      const retrieveFilenames = require('./retrieveFilenames');
      const validateFiles = require('./validateFiles');
  
      fs.existsSync.mockReturnValue(true);
      path.isAbsolute.mockReturnValue(true);
      retrieveFilenames.mockReturnValue(['file1.js', 'file2.js']);
      validateFiles.mockReturnValue({ valid: ['file1.js'], invalid: ['file2.js'] });
  
      const options = { schema: '/absolute/path/to/schema', verbose: false };
      const patterns = ['*.js'];
      const fallbackPatterns = ['*.ts'];
  
      const result = processFiles(options, patterns, fallbackPatterns);
  
      expect(result.valid).toEqual(['file1.js']);
      expect(result.invalid).toEqual(['file2.js']);
    });

    // Sends informative messages when verbose option is enabled
    it('should send informative messages when verbose option is enabled', () => {
      const path = require('path');
      const fs = require('fs');
      jest.mock('fs');
      jest.mock('path');
      jest.mock('./retrieveFilenames');
      jest.mock('./validateFiles');
  
      const retrieveFilenames = require('./retrieveFilenames');
      const validateFiles = require('./validateFiles');
      const sendMessage = jest.fn();
  
      fs.existsSync.mockReturnValue(true);
      path.isAbsolute.mockReturnValue(true);
      retrieveFilenames.mockReturnValue(['file1.js', 'file2.js']);
      validateFiles.mockReturnValue({ valid: ['file1.js'], invalid: ['file2.js'] });
  
      const options = { schema: '/absolute/path/to/schema', verbose: true };
      const patterns = ['*.js'];
      const fallbackPatterns = ['*.ts'];
  
      processFiles(options, patterns, fallbackPatterns);
  
      expect(sendMessage).toHaveBeenCalledWith(true, 'skelosaurus', 'info', expect.stringContaining('Invalid files'));
      expect(sendMessage).toHaveBeenCalledWith(true, 'skelosaurus', 'info', expect.stringContaining('Valid files'));
    });

    // Manages relative schema paths by throwing an error
    it('should throw an error for relative schema paths', () => {
      const path = require('path');
      const fs = require('fs');
      jest.mock('fs');
      jest.mock('path');
  
      fs.existsSync.mockReturnValue(true);
      path.isAbsolute.mockReturnValue(false);
  
      const options = { schema: './relative/path/to/schema', verbose: false };
      const patterns = ['*.js'];
      const fallbackPatterns = ['*.ts'];
  
      expect(() => processFiles(options, patterns, fallbackPatterns)).toThrow('Invalid schema path');
    });
});
